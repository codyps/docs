var searchIndex = {};
searchIndex["hash_roll"] = {"doc":"","items":[[3,"Range","hash_roll","",null,null],[12,"first","","",0,null],[12,"last","","",0,null],[3,"SplitterSlices","","Iterator over slices emitted from a splitter",null,null],[3,"SplitterVecs","","Iterator over vecs emitted from a splitter",null,null],[4,"Bound","","",null,null],[13,"Included","","",1,null],[13,"Excluded","","",1,null],[13,"Unbounded","","",1,null],[0,"bup","","",null,null],[3,"RollSum","hash_roll::bup","Rolling sum used in Bup. This is based on the one in librsync.",null,null],[3,"Bup","","",null,null],[11,"digest","","",2,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"add","","",2,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"u8"}],"output":null}],[11,"roll_byte","","",2,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"roll","","",2,null],[11,"sum","","",2,null],[11,"at_split","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bup"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"find_chunk_edge","","",3,null],[11,"next_iter","","",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[0,"zpaq","hash_roll","",null,null],[3,"Zpaq","hash_roll::zpaq","A splitter used in go 'dedup' and zpaq that does not require looking back in the source data to update",null,null],[3,"ZpaqHash","","The rolling hash component of the zpaq splitter",null,null],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"zpaq"}}],[11,"with_range","","Create a splitter using the range of output block sizes.",4,{"inputs":[{"name":"range"}],"output":{"name":"self"}}],[11,"with_average_size","","Create a splitter using the defaults from Zpaq (the compressor) given a average size is base 2 (zpaq argument \"-fragment\")",4,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[11,"with_max_size","","Use the defaults from go-dedup to generate a splitter given the max size of a split.",4,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"with_average_and_range","","Create a splitter with control of all parameters",4,{"inputs":[{"name":"u8"},{"name":"range"}],"output":{"name":"self"}}],[11,"default","","Create a splitter using the defaults from Zpaq (the compressor)",4,{"inputs":[],"output":{"name":"self"}}],[11,"find_chunk_edge","","",4,null],[11,"next_iter","","",4,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"default","","",5,{"inputs":[],"output":{"name":"self"}}],[11,"feed","","",5,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"u32"}}],[0,"rsyncable","hash_roll","",null,null],[3,"Rsyncable","hash_roll::rsyncable","Window-based splitter using a simple accumulator & modulus hash.",null,null],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"rsyncable"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"find_chunk_edge","","",6,null],[11,"next_iter","","",6,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"with_window_and_modulus","","",6,{"inputs":[{"name":"usize"},{"name":"u64"}],"output":{"name":"rsyncable"}}],[11,"default","","",6,{"inputs":[],"output":{"name":"self"}}],[8,"Splitter","hash_roll","An object with transforms a stream of bytes into chunks, potentially by examining the bytes",null,null],[11,"find_chunk_edge","","Find the location (if any) to split `data` based on this splitter.",7,null],[11,"split","","Split data into 2 pieces using a given splitter.",7,null],[10,"next_iter","","Return chunks from a given iterator, split according to the splitter used.",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"into_slices","","Create an iterator over slices from a slice and a splitter. The splitter is consumed.",7,null],[11,"as_slices","","",7,null],[11,"into_vecs","","Create an iterator of `Vec<u8>` from an input Iterator of bytes. The splitter is consumed.",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"splittervecs"}}],[11,"as_vecs","","",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"splittervecs"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"splitterslices"}}],[11,"from","","",8,null],[11,"next","","",8,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",8,null],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"splittervecs"}}],[11,"from","","",9,{"inputs":[{"name":"p"},{"name":"t"}],"output":{"name":"self"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",9,null]],"paths":[[3,"Range"],[4,"Bound"],[3,"RollSum"],[3,"Bup"],[3,"Zpaq"],[3,"ZpaqHash"],[3,"Rsyncable"],[8,"Splitter"],[3,"SplitterSlices"],[3,"SplitterVecs"]]};
initSearch(searchIndex);
